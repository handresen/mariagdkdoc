====== Notification Management ======
Geo Fence Nottifications are accessed through 
[[http://support.teleplanglobe.com/MariaGDKDoc/html/C0536256.htm|INotificationHandlingService Interface]] of the Geo Fencing Service.

For additional information, see [[maria_gdk:programming:functionality:geofencing:notifications|Notifications]]

===== Connect to service =====
 
Create an interface class (//GeoFenceNotificationsViewModel//) for notification management, inheriting ViewModelBase.
<code csharp>
public class GeoFenceNotificationsViewModel : ViewModelBase
{
}
</code>

Create a constructor, and connect to the NotificationHandling part of the GeoFencingService. The code will look like this: 

<code csharp>
private IBindingFactory _bindingFactory = new BindingFactory();
private IEndpointAddressFactory _endpointAddressFactory = new EndpointAddressFactory();
private NotificationHandlingServiceClient _clientNotification;
. . .
public GeoFenceNotificationsViewModel()
{
    _clientNotification =
        new NotificationHandlingServiceClient(
            _bindingFactory.NewFromConfigurationFile(GeoFenceDefs.DefaultGeoFenceNotificationName),
            _endpointAddressFactory.NewFromConfigurationFile(GeoFenceDefs.DefaultGeoFenceNotificationName));

    _clientNotification.ServiceConnected += OnNotificationClientServiceConnected;
    _clientNotification.Connect();
}

private void OnNotificationClientServiceConnected(object sender, EventArgs args)
{
}
</code>


Make sure that your App.config file contains an end point specification for the GeoFencingService/NotificationHandling. See [[maria_gdk:programming:getting_started:mariabasicmapclient:service_configuration|Service Configuration]].

Then, define and instansiate the GeoFenceNotificationsViewModel in the declarations and constructor of the main view model (MariaWindowViewModel).
<code csharp>
public GeoFenceNotificationsViewModel GeoFenceNotificationsViewModel { get; set; }
. . .
public MariaWindowViewModel()
{
    . . .
    GeoFenceNotificationsViewModel = new GeoFenceNotificationsViewModel();
    . . .
}
</code>

===== Collect Notifications =====

Our first step is to collect current notifications from the connected service, and display the result.\\
For this, we need to add a list property and a command handler to the view model.

<code csharp>
private NotificationQueryResult _notifications;

public ObservableCollection<string> DisplayListItems { get; private set; }

public ICommand PollCmnd { get { return new DelegateCommand(x => PollNotifications()); } }

public GeoFenceNotificationsViewModel()
{
    DisplayListItems = new ObservableCollection<string>();
    . . .
}
. . .
private void PollNotifications()
{
    if (_clientNotification == null || !_clientNotification.Connected)
        return;

    _notifications = _clientNotification.GetNotifications("", -1);

    DisplayListItems.Clear();
    if (_notifications != null)
    {
        foreach (var item in _notifications.Notifications)
        {
            DisplayListItems.Add(item.Heading);
        }
    }
    NotifyPropertyChanged(() => DisplayListItems); 
}
</code>

Then add a button and a list box to the GUI, and bind them to the new view model properties.
<code xml>
<Button  MinWidth="60" HorizontalAlignment="Left"  Margin="0,0,5,0"
         Content="Poll"
         Command="{Binding GeoFenceNotificationsViewModel.PollCmnd}" />

<GroupBox Header="Notifications:">
    <ListBox Height="Auto" VerticalAlignment="Top" MinWidth="40"
             ItemsSource="{Binding GeoFenceNotificationsViewModel.DisplayListItems}"
             />
</GroupBox>
</code>

<WRAP round box >
All current notifications from the service are now displayed. The number of items may be large!
It will look like this:
</WRAP>

{{:maria_gdk:programming:getting_started:mariageofencing:3-notificationmanagement:notificationcollection.png?nolink|Notification Collection}}

==== Reduce amount of Notifications ====
Notifications are collected by request, and by default, all notifications are collected. As we normally are interested in a limited set of information, there are two different ways to reduce the information.

  * Retreive by "Generation"
  * Specify filter conditions

The reduction methods can be used saparately, or in combination.
 
=== Notification generations ===

The Geo Fencing Service, Notification Handling maintains a "generation" counter. The counter value is stepped up every time new geo fence events are detected. The current generation is available in the returned notification result.

By specifying the generation counter of the last read information, you will have a mechanism that retrieves new notifications only.

<code csharp>
public class GeoFenceNotificationsViewModel : ViewModelBase
{
    . . .
    private void PollNotifications()
    {
        . . .
        _notificationResult = 
          _clientNotification.GetNotifications("", 
                                               (_notificationResult != null) ?
                                               _notificationResult.Generation :
                                               -1);
        . . .
    }
</code>

<WRAP round box >
The result will look like this:
</WRAP>
{{ :maria_gdk:programming:getting_started:mariageofencing:3-notificationmanagement:notifications_by_generations.png?nolink&500 |Notification by Generation}}

=== Filtering notifications ===

The notification filter is an XML string, specifying one or or several conditions. Here we will include a simple filter supressing low level notifications, and a composite filter supressing low level notifcations older than 60 seconds. We'll also add automatic poll whenever the filter conditions change.

In the view model, add the following properties:

<code csharp>
private string _conditionXml;
public string ConditionXml
{
    get { return _conditionXml; }
    set
    {
        _conditionXml = value;
        NotifyPropertyChanged(() => ConditionXml);
    }
}

private bool _supressLowLevel;
public bool SupressLowLevel
{
    get { return _supressLowLevel; }
    set
    {
        _supressLowLevel = value;
       
        NotifyPropertyChanged(() => SupressLowLevel);
        PollNotifications();
    }
}

private bool _includeAllNew;
public bool IncludeAllNew
{
    get { return _includeAllNew; }
    set
    {
        _includeAllNew = value;

        NotifyPropertyChanged(() => IncludeAllNew);
        PollNotifications();
    }
}

</code>

Update the polling mechanism:
<code csharp>
. . .
private void PollNotifications()
{
    . . .    
    // By filter conditions
    UpdateConditionXml();
    _notificationResult = _clientNotification.GetNotifications(ConditionXml, -1);
    . . .    
}
  
private void UpdateConditionXml()
{
    var conditionXml = "";
    var compMainCondition = new CompositeCondition { Operator = GroupOperator.And };

    if (SupressLowLevel)
    {
        var compSubCondition = new CompositeCondition { Operator = GroupOperator.Or };
        compSubCondition.Children.Add(new FieldCondition("Level", 
                                                         NotificationLevel.Low.ToString(), 
                                                         FieldOperator.NEq));

        if (IncludeAllNew)
        {
            compSubCondition.Children.Add(new AgeCondition { Operator = FieldOperator.Lt, 
                                                            Age = 60.0 });
        }
        conditionXml = GenericFielsConditionFilter(compSubCondition);
        compMainCondition.Children.Add(compSubCondition);
    }

    ConditionXml = conditionXml;
}

private string GenericFielsConditionFilter(ICondition condition)
{
    var filterXml = @"<GeoFencingFilters>"
                    + (new ConditionXmlParser(new ConditionFactory())).WriteCondition(condition)
                    + @"</GeoFencingFilters>";

    var fsp = new GeoFencingXmlParserUtils();
    var result = fsp.ParseGeoFenceFilters(filterXml);

    return result;
}
</code>

Then add components and bindings to the GUI:

<code xml>
<GroupBox Header="Filters" >
    <StackPanel Orientation="Vertical">
        <CheckBox Content="Level - Suppress 'Low'"
                  IsChecked="{Binding GeoFenceNotificationsViewModel.SupressLowLevel}" />
        <CheckBox Content="Age - Include all new!"
                  IsChecked="{Binding GeoFenceNotificationsViewModel.IncludeAllNew}" 
                  IsEnabled="{Binding GeoFenceNotificationsViewModel.SupressLowLevel}"/>        
        <GroupBox>
            <Label Content="{Binding GeoFenceNotificationsViewModel.ConditionXml}" />
        </GroupBox>
    </StackPanel>
</GroupBox>
</code>

<WRAP  round box >
After creating some notifications of different levels, the result with different filters would be something like this:
</WRAP>
{{ :maria_gdk:programming:getting_started:mariageofencing:3-notificationmanagement:notification_filters.png?nolink&500 | Filtered Notifications }}

<WRAP center round info >
Examples of filtering according to specific tracks and drawobjects can be found in [[maria_gdk:programming:getting_started:mariageofencing:4-visualization|Visualization]]

</WRAP>

==== Add user data to notification. ====
It is not possible to modify the notification information, however, it is possible to add user data, like processing information.  
In the sample application, you can find an example of adding acknowledged tag to selected notification item, with corresponding "Acknowledged" filter. Setting the acknowledge tag like this:

<code csharp>
_clientNotification.SetNotificationUserData(
  _notificationResult.Notifications[SelectedNotificationItemIndex].Id,
  new UserDataDefinition 
  {
    Owner = "MariaGeoFenceTestClient", 
    Key = "userdata/*/state", 
    Value = "acknowledged" 
  });

PollNotifications();
</code>

Details for items selction and filter setting is found in the sample code.

<WRAP round box >
The result will be like this:
</WRAP>

{{ :maria_gdk:programming:getting_started:mariageofencing:3-notificationmanagement:acknowledge.png?nolink&500 | Notification Acknowledge}}

