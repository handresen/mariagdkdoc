===== Visualization =====
{{ :maria_gdk:programming:getting_started:mariageofencing:3-notificationmanagement:visualization-showselected.png?direct&200|}}
This section gives an example of visualization of Geo Fence information, from //GeoFenceRuleViewModel// and //GeoFenceNotificationsViewModel//, in a custom layer of the map - with additional GUI components to manage the visualization.

The following are to be visualized :
^ Notification elements | Line between first- and last- track position. Color according to notification level. ((See [[http://support.teleplanglobe.com/MariaGDKDoc/html/D5E9F28E.htm|NotificationDef]])) \\ Ledger line to current track possition, for selected tracks or notifications only. |
^ Moving Ranges | Range circle(s) for Moving Range Tracks. |

==== Custom Classes ====

Create custom Layer (//GeoFencingLayer//) and View (//GeoFencingView//) classes with corresponding factories (//GeoFencingLayerFactory// and //GeoFencingViewFactory//) ((As decribed in [[maria_gdk:programming:getting_started:custom_layers|Maria Custom Layer]])).

<code csharp>
public class GeoFencingLayer : GeoLayerViewModel { . . . }
public class GeoFencingLayerFactory : IMariaCustomLayerFactory { . . . }
public class GeoFencingView : Grid, IGeoLayerView { . . . }
public class GeoFencingViewFactory : IGeoLayerViewFactory { . . . }
</code>

=== Data Classes ===
Add classes for data transfer from the view models to the custom layer, and between the custom layer and custom view:

<code csharp>
public enum VisualInfoType
{
    EventPossitions,
    LedgerLine,
    LedgerEllipsis,
}

public abstract class VisualData
{
    public Pen LinePen { get; set; }
    public Point PtStart { get; set; }
}

public class VisualLine : VisualData
{
    public Point PtEnd { get; set; }
}
public class VisualEllipsis : VisualData
{
    public Brush FillBrush { get; set; }
    public double RadiusX { get; set; }
    public double RadiusY { get; set; }
}

public class VisualMovingRangeInfo
{
    public LatLonPos PtCentre { get; set; }
    public double MovingRange { get; set; }
}

public class CustomNotificationDef
{
    public NotificationDef Def { get; set; }

    public LatLonPos CurrentTrackPos { get; set; }

    public CustomNotificationDef(NotificationDef item) 
    {
        Def = item;
    }
}
</code>  

=== View ===
In the custom **view** class, //GeoFencingView//, add and initialize lists for screen information (//VisualData//) to be visualized and rendering code:
<code csharp>
public List<VisualData> VisualNotifications { get; private set; }
public List<VisualData> VisualMovingRanges { get; set; }

public GeoFencingView()
{
    . . .
    VisualNotifications = new List<VisualData>();
    VisualMovingRanges = new List<VisualData>();
}
. . .
private void Render(DrawingContext dc)
{
    RenderList(dc, VisualMovingRanges);
    RenderList(dc, VisualNotifications);
}
private static void RenderList(DrawingContext dc, List<VisualData> items)
{
    foreach (var element in items)
    {
        if (element.GetType() == typeof (VisualLine))
        {
            var line = (VisualLine) element;
            dc.DrawLine(line.LinePen, line.PtStart, line.PtEnd);
        }
        else if (element.GetType() == typeof (VisualEllipsis))
        {
            var ellipsis = (VisualEllipsis) element;
            dc.DrawEllipse(ellipsis.FillBrush,
                ellipsis.LinePen, ellipsis.PtStart,
                ellipsis.RadiusX, ellipsis.RadiusY);
        }
    }
}
</code>

=== Layer ===
In the custom **layer** class, //GeoFencingLayer//, add update methods, converting lists with 
geographic info for notifications (//CustomNotificationDef//) and  moving ranges (//VisualMovingRangeInfo//) 
to screen information (//VisualData//). \\  
Also implement clear functions, and initialize pen and brush to be used for moving ranges.

<code csharp>
private readonly Pen _rangePen;
private readonly Brush _ranegBrush;
. . .
public GeoFencingLayer()
{
    . . .    
    _rangePen = new Pen(new SolidColorBrush(Colors.DodgerBlue), 2) 
    {
      DashStyle = DashStyles.Dash 
    };
    _ranegBrush = new SolidColorBrush(Colors.Transparent);
}
. . .
public void ClearVisualNotifications()
{
    _view.VisualNotifications.Clear();
    _view.Generate();
}
public void ClearVisualMovingRanges()
{
    _view.VisualMovingRanges.Clear();
    _view.Generate();
}
public void UpdateMovingRange(IEnumerable<VisualMovingRangeInfo> list)
{
    if (list == null)
        return;

    _view.VisualMovingRanges.Clear();
    foreach (var element in list)
    {
        var pixelRange = RangeToPixelLength(element.PtCentre, element.MovingRange);
        var centerPt = LatLonPosToPoint(element.PtCentre);

        _view.VisualMovingRanges.Add(new VisualEllipsis
        {
            PtStart = centerPt,
            FillBrush = _ranegBrush,
            LinePen = _rangePen,
            RadiusX = pixelRange,
            RadiusY = pixelRange
        });
    }
}

public void UpdateVisualisation(IEnumerable<CustomNotificationDef> list, bool assosiateWithTrack)
{
    if (list == null)
        return;
    
    _view.VisualNotifications.Clear();
    foreach (var element in list)
    {
        var start = LatLonPosToPoint(element.Def.FirstTrackPos);
        var end = LatLonPosToPoint(element.Def.LastTrackPos);
        _view.VisualNotifications.Add(
            new VisualLine
            {
                PtStart = start,
                PtEnd = end,
                LinePen = PenFromDefinition(element.Def, VisualInfoType.EventPossitions)
            });

        if (element.CurrentTrackPos != null && assosiateWithTrack)
        {
            var track = LatLonPosToPoint(element.CurrentTrackPos);
            _view.VisualNotifications.AddRange(new[]
            {
                new VisualLine
                {
                    PtStart =  start,
                    PtEnd =  track,
                    LinePen = PenFromDefinition(element.Def, VisualInfoType.LedgerLine)
                },
                new VisualLine
                {
                    PtStart =  end,
                    PtEnd =  track,
                    LinePen = PenFromDefinition(element.Def, VisualInfoType.LedgerLine)
                }
            });
        }
    }
}

private double RangeToPixelLength(LatLonPos posLatLon, double lenMeter)
{
    if (GeoContext != null)
    {
        Point ptS, ptE;
        var posStart = new GeoPos(posLatLon.Lat, posLatLon.Lon);
        var endpoint = Earth.BearingRangeToPos(posStart, 
                                               new BearingRange(0, lenMeter));

        GeoContext.Viewport.LatLonToXY(posStart, out ptS);
        GeoContext.Viewport.LatLonToXY(endpoint, out ptE);

        return ptS.Y - ptE.Y;
    }
    return 0.0;
}
private Point LatLonPosToPoint(LatLonPos posLatLon)
{
    if (GeoContext != null)
    {
        Point pt;
        GeoContext.Viewport.LatLonToXY(new GeoPos(posLatLon.Lat, 
                                                  posLatLon.Lon), 
                                       out pt);
        return pt;
    }

    return new Point();
}

private Pen PenFromDefinition(NotificationDef def, VisualInfoType type)
{
    var color = Colors.DimGray;
    var width = 2;
    var dash = DashStyles.Solid;

    if (def.GetUserDataTagValue(GeoFenceDefs.OwnerName, 
                                GeoFenceDefs.StateKey) != 
        GeoFenceDefs.AcknowledgedValue)
    {
        switch (def.Level)
        {
            case NotificationLevel.Low:
                color = Colors.LimeGreen;
                break;
            case NotificationLevel.Medium:
                color = Colors.Yellow;
                break;
            case NotificationLevel.High:
                color = Colors.Red;
                break;
        }
    }
    if (type == VisualInfoType.EventPossitions)
        width = 4;
    else
        dash = DashStyles.Dash;

    return new Pen(new SolidColorBrush(color), width) { DashStyle = dash };
}
</code>

==== Extend View models ====
Add fields and constructor parameters for the following interfaces with event handlers to the view models 
(//GeoFenceRuleViewModel// and //GeoFenceNotificationsViewModel//):

^ Interface        | Name | Event handlers |
^ IMariaTrackLayer | _trackLayer | ExtendedTrackLayer.TrackSelectionChanged((//GeoFenceNotificationsViewModel// only)) \\ ExtendedTrackLayer.CurrentTrackDisplayItemsChanged |
^ IMariaDrawObjectLayer | _drawObjectLayer | ExtendedDrawObjectLayer.LayerSelectionChanged((//GeoFenceNotificationsViewModel// only)) \\ ExtendedDrawObjectLayer.LayerChanged((//GeoFenceNotificationsViewModel// only)) |
^ CustomLayer<GeoFencingLayer>| _customLayer | LayerInitialized |
^ GeoFencingLayer | _geoFencingLayer | |

<code csharp>
. . .
private readonly IMariaDrawObjectLayer _drawObjectLayer;
private readonly IMariaTrackLayer _trackLayer;
private readonly CustomLayer<GeoFencingLayer> _customLayer;
private GeoFencingLayer _geoFencingLayer;
. . .
public GeoFenceRuleViewModel(  // and GeoFenceNotificationsViewModel 
    IMariaTrackLayer trackLayer, 
    IMariaDrawObjectLayer drawObjectLayer, 
    CustomLayer<GeoFencingLayer> customLayer)
{
    _trackLayer = trackLayer;
    _drawObjectLayer = drawObjectLayer;
    _customLayer = customLayer;
    _geoFencingLayer = _customLayer.Instance;

    _drawObjectLayer.ExtendedDrawObjectLayer.LayerSelectionChanged += 
      		OnGeoshapeSelectionChanged;
    _drawObjectLayer.ExtendedDrawObjectLayer.LayerChanged += 
      		DrawObjectLayerOnLayerChanged;

    _trackLayer.ExtendedTrackLayer.TrackSelectionChanged +=
      		OnTrackSelectionChanged;
    _trackLayer.ExtendedTrackLayer.CurrentTrackDisplayItemsChanged += 
      		CurrentTrackDisplayItemsChanged;

    _customLayer.LayerInitialized += OnGeoFenceLayerInitialized;  
    . . .
}
private void OnGeoFenceLayerInitialized()
{
    _geoFencingLayer = _customLayer.Instance;
}
private void CurrentTrackDisplayItemsChanged()
{
}
private void OnTrackSelectionChanged(object sender, 
                                     TrackSelectionChangedEventArgs args)
{
}
private void DrawObjectLayerOnLayerChanged(object sender, 
                                           DataStoreChangedEventArgs args)
{
}
private void OnGeoshapeSelectionChanged(object sender, 
                                        DrawObjectSelectionChangedEventArgs args)
{
}
. . .
</code>

=== Additional GUI with corresponding properties ===
Add properties for visualization handling, initialize in the //LayerInitialized// event handler. 

== GeoFenceRuleViewModel ==
<code csharp>
private bool _showMovingRanges;
public bool ShowMovingRanges
{
    get { return _showMovingRanges; }
    set
    {
        _showMovingRanges = value;
    }
}
private void OnGeoFenceLayerInitialized()
{
    _geoFencingLayer = _customLayer.Instance;
    ShowMovingRanges = true;
}

</code>

== GeoFenceNotificationsViewModel ==
<code csharp>
private bool _visualizeNotifications;
public bool VisualizeNotifications
{
    get { return _visualizeNotifications; }
    set
    {
        _visualizeNotifications = value;

        NotifyPropertyChanged(() => VisualizeNotifications);
        NotifyPropertyChanged(() => VisualizeSelectedNotification);
        NotifyPropertyChanged(() => VisualizeSelectedTracksOrGeoShapes);
    }
}
private bool _visualizeSelectedNotification;
public bool VisualizeSelectedNotification
{
    get { return _visualizeSelectedNotification; }
    set
    {
        _visualizeSelectedNotification = value;

        if (value)
        {
            _visualizeSelectedTracksOrGeoShapes = false;
        }

        NotifyPropertyChanged(() => VisualizeSelectedNotification);
        NotifyPropertyChanged(() => VisualizeSelectedTracksOrGeoShapes);

        PollNotifications();
    }
}
private bool _visualizeSelectedTracksOrGeoShapes;
public bool VisualizeSelectedTracksOrGeoShapes
{
    get { return _visualizeSelectedTracksOrGeoShapes; }
    set
    {
        _visualizeSelectedTracksOrGeoShapes = value;
        if (value)
        {
            _visualizeSelectedNotification = false;
        }

        NotifyPropertyChanged(() => VisualizeSelectedNotification);
        NotifyPropertyChanged(() => VisualizeSelectedTracksOrGeoShapes);

        PollNotifications();
    }
}
. . .
private void OnGeoFenceLayerInitialized()
{
    _geoFencingLayer = _customLayer.Instance;

    VisualizeNotifications = true;
    VisualizeSelectedTracksOrGeoShapes = false;
    VisualizeSelectedNotification = false;
}
</code>
 
Extend the condition creator to handle visualization as well! See samplecode for details.

=== Main window XAML ===
Then, add visualization GUI:

<code xml>
<GroupBox Header="Visualiisation" >
    <StackPanel Orientation="Vertical">
        <CheckBox  Content="Visualize Notifications"
                   IsChecked="{Binding GeoFenceNotificationsViewModel.VisualizeNotifications}" />
        <CheckBox Content="Selected Notification"
                  IsEnabled="{Binding GeoFenceNotificationsViewModel.VisualizeNotifications}"
                  IsChecked="{Binding GeoFenceNotificationsViewModel.VisualizeSelectedNotification}" />
        <CheckBox Content="Selected Tracks/Geo Shapes"
                  IsEnabled="{Binding GeoFenceNotificationsViewModel.VisualizeNotifications}"
                  IsChecked="{Binding GeoFenceNotificationsViewModel.VisualizeSelectedTracksOrGeoShapes}" />
        <CheckBox Content="Visualization Moving Ranges"
                  IsChecked="{Binding GeoFenceRuleViewModel.ShowMovingRanges}" />
    </StackPanel>
</GroupBox>
</code>

== View Models, final tutch ==
Finally, update the view models, //GeoFenceRuleViewModel// and //GeoFenceNotificationsViewModel//, 
to utilize the visualization.

Implement update methods for notifications and moving ranges respectively, and call update/polling when required.

== GeoFenceRuleViewModel ==
<code csharp>
public bool ShowMovingRanges
{
    . . .
    set
    {
        . . .
        if (value)
            UpdateMovingRange();
        else
            _geoFencingLayer.ClearVisualMovingRanges();
    }
}
. . .
private void CurrentTrackDisplayItemsChanged()
{
    UpdateMovingRange();
}  
. . .
private void UpdateMovingRange()
{
    if (_geoFencingLayer == null)
        return;

    var listOfMrInfo = new List<VisualMovingRangeInfo>();
    if (ShowMovingRanges && _mrdList != null)
    {
        //var rect = _trackLayer.GeoContext.Viewport.GeoRect;
        //rect.InflateRelative(2.0);
        var list = _trackLayer.ActiveTrackList;

        foreach (var mrd in _mrdList)
        {
            var tracks = _trackLayer.GetTrackData(mrd.TrackId);
            if (tracks == null || tracks.Length < 1 || !tracks[0].Pos.HasValue)
                continue;

            listOfMrInfo.Add(new VisualMovingRangeInfo
            {
                PtCentre = new LatLonPos(tracks[0].Pos.Value.Lat, tracks[0].Pos.Value.Lon),
                MovingRange = mrd.RangeMeters
            });           
        }
    }

    _geoFencingLayer.UpdateMovingRange(listOfMrInfo);
}
</code>

== GeoFenceNotificationsViewModel ==
<code csharp>
public int SelectedNotificationItemIndex
{
    . . .
    set
    {
        . . .
        UpdateVisualisation();
    }
}
. . .
public bool VisualizeNotifications
{
    . . .
    set
    {
        . . .
        if (value)
            UpdateVisualisation();
        else
            _geoFencingLayer.ClearVisualNotifications();
    }
}
. . .  
private void CurrentTrackDisplayItemsChanged()
{
    UpdateVisualisation();
}
private void OnTrackSelectionChanged(object sender, TrackSelectionChangedEventArgs args)
{
    if (!VisualizeSelectedNotification)
        PollNotifications();
    else
        UpdateVisualisation();
}
private void DrawObjectLayerOnLayerChanged(object sender, DataStoreChangedEventArgs args)
{
    UpdateVisualisation();
}
private void OnGeoshapeSelectionChanged(object sender, DrawObjectSelectionChangedEventArgs args)
{
    if (!VisualizeSelectedNotification)
        PollNotifications();
    else
        UpdateVisualisation();
}
private void PollNotifications()
{
    . . .
    UpdateVisualisation();
}
private void UpdateVisualisation()
{
    if (_geoFencingLayer == null)
        return;

    if (!VisualizeNotifications || _notificationResult == null || _notificationResult.Notifications == null)
        return;

    if (VisualizeSelectedNotification)
    {
        if (!IsNotificationItemSelected)
            return;

        var customList = CreateCustomNotifications(_notificationResult.Notifications[SelectedNotificationItemIndex]);
        _geoFencingLayer.UpdateVisualisation(customList, true);
    }
    else
    {
        var customList = CreateCustomNotifications(_notificationResult.Notifications.ToArray());
        _geoFencingLayer.UpdateVisualisation(customList, VisualizeSelectedTracksOrGeoShapes);
    }
}
private IEnumerable<CustomNotificationDef> CreateCustomNotifications(params NotificationDef[] list)
{
    var customList = new List<CustomNotificationDef>();

    foreach (var item in list)
    {
        var rec = new CustomNotificationDef(item);

        var tracks = _trackLayer.GetTrackData(item.TrackId.ObjectId);

        if (tracks != null && tracks.Length > 0 && tracks[0].Pos.HasValue)
            rec.CurrentTrackPos = new LatLonPos(tracks[0].Pos.Value.Lat, tracks[0].Pos.Value.Lon);
        customList.Add(rec);
    }
    return customList;
}
</code>

<WRAP round box >
After moving tracks around to cretae notifications, with shapes, rules and moving ranges defined, visualisation can be be altered as shown below:
</WRAP>

  * Show all:
{{ :maria_gdk:programming:getting_started:mariageofencing:3-notificationmanagement:visualization-showall.png?direct&500 |Visualization - Show all}}

  * Show selected notification:
{{ :maria_gdk:programming:getting_started:mariageofencing:3-notificationmanagement:visualization-shownotification.png?direct&500 |Visualization - Show selected notification}}

  * Show selected tracks/shapes:
{{ :maria_gdk:programming:getting_started:mariageofencing:3-notificationmanagement:visualization-showselected.png?direct&500 |Show selected tracks/shapes}}

  * Supress visualization:
{{ :maria_gdk:programming:getting_started:mariageofencing:3-notificationmanagement:visualization-supressed.png?direct&500 | Supress visualization}}